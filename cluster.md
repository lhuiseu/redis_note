#1 概念
    1.节点：运行在集群模式下的Redis服务器。Redis服务器在启动的时候，会根据cluster_enabled配置选项是否为yes
      决定是否开启服务器的集群模式（与之对应的是单机模式）。
    2.数据槽：Redis通过分片的方式来保存数据库中的键值对。
  
  **集群的整个数据库被分成了16384个槽，数据库中的每一个键都属于这些槽里面的一个**
  **集群中的节点可以处理0个或最大16384个槽**
    
    3.集群上线状态
  
  **数据库中的16384个槽都有节点处理，集群处于上线状态**
    
    节点执行以下命令，可以负责多个槽
    cluster addslots ... 
    
    4.集群下线状态
  **数据库中有任意一个槽没有节点处理，则集群处于下线状态**  
      
#2 数据结构
    1.clusterNode 
        char ip[REDIS_IP_STR_LEN]
        int port 
        
        clusterLink *link
        
        //是一个二进制数组，这个数组的长度是16384／8个字节，共包含16384个二进制位
        //如果slots数组，索引i上的节点为1，表示该节点负责处理槽i。反之，不负责
        //判定节点是否负责某个槽，或者让节点去负责一个槽的算法复杂度都是O(1)
   **虽然与下文clusterState结构中的slots数组有一点冗余，但是这都是为了效率而言的**
   **比如同步给，其他节点的时候，直接发送这个数组就可以了**
   
        unsigned char slots[16384/8]
        
        //节点负责槽的数量
        numslots
        
        //从节点指向的主节点
        struct clusterNode *slaveof
        
        //从节点数量
        int numslaves
        
        //从节点构成的数组
        struct clusterNode **slaves
        
        //一个链表，记录了其他节点对该节点的下线报告
        list *fail_reports  
        
    2.clusterLink
        int fd
        
        //输出缓冲区，保存待发送给其他节点的消息
        sds sndbuf
        
        //输入缓冲区。保存着从其他节点接收到的消息。
        sds rcvbuf
        
        //与这个连接相关联的节点，如果没有为NULL
        struct clusterNode *node
   **注意这个结构和redisClient的区别，二者都保存了套接字描述符和输入、输出缓冲区。但是**
   **redisClient是面向客户端连接的，而clusterLink则是面向连接节点的**
        
    
    3.clusterState
   **该结构记录当前节点的视角下，集群目前所处的状态**
        
        //指向当前节点的指针
        clusterNode *myself
        
        //集群当前的纪元
        uuint64_t currentEpoch
        
        //集群当前的状态
        int state 
        
        //集群节点名单，包括自己
        dict *nodes
        
        //记录集群中槽的指派信息，每一项都是指向clusterNode的指针
        //如果，某个index的值为NULL。表示尚未指派
   **如果节点只是用clusterState.nodes结构里 clusterNode的slots数组，那么如果要知道槽i是否被指派**
   **需要遍历clusterState.nodes里的所有clusterNode，检查这些结构的slots数组，知道找到负责槽i的节点为至**
        
        //故，新增了这个数组
        clusterNode *slots[16384]
        
        //一个跳跃表，记录了各个数据库键所属的槽
        //每当节点往数据库中添加一个新的键值对时，节点会将这个键以及这个键对应的槽号关联到slots_to_keys跳跃表中去
        //删除则解除
        //通过这个结构，可以获取某个槽或者某些槽的所有数据库键
        zskiplist *slots_to_keys
        
        //当前节点正在从其他节点导入的槽。如果所以i位置不为NULL，表示当前节点正在导入i槽的数据
        clusterNode *importing_slots_from[16438]
        
        //当前节点正在将槽i迁移至clusterNode所代表的节点。当分片过程中，如果键所在的槽正在被迁移，那么如果当前节点找不到该键，会将迁移节点的信息返回给客户端
        clusterNode *migrating_slots_to[16438]
        
    4.clusterNodeFailReport
        //报告目标节点已经下线的节点
        struct clusterNode *node 
        
        //最后一次从node节点收到下线报告的时间,判断报告是否过期
        mstime_t time
        
#3  指令实现
    1.Cluster meet ip port 实现
        1）客户端发送命令，给A。收到命令的A将与B进行握手
        2）没有握手之前，节点A首先创建B的clusterNode结构，并添加到自己clusterState的nodes字段里
        
        3）A给B发送meet消息
        4）B收到A的消息，将为A创建clusterNode结构，并添加到自己的clusterState的nodes字典
        5）B给A 回复PONG消息
        6）A再向B发送一个PING消息（让B知道自己的接受能力），握手成功
        
  **之后节点A将通过gossip协议传播给集群的其他节点，让其他节点也与B进行握手，最终经过一段时间B将被集群中的其他节点认识**
  
    2.cluster addslots
        1) 遍历所有输入槽，判定是否都未指派，但凡一个指派，返回错误
        2) 再次遍历所有输入槽，设定clusterState 的相应index指向当前的clusterNode
        3) 将当前clusterNode 中slots的第i位，置成1
        4）节点发消息告知其他节点自己当前负责了哪些槽
#4 传播节点的槽指派信息
    1.一个节点出了将自己负责的槽信息保存在clusterNode结构里面，同时还会将自己的槽信息告知其他节点，
      以告知其他节点，自己目前负责哪些槽
    2.收到信息的节点，将更新自己clusterState.nodes字典 相应节点clusterNode的slots数组进行保存或更新
    3.因此集群中的每一个节点都知道数据库的16384个槽分别指派给了集群中的哪些节点
    

#5 集群中执行命令
    1.当集群上线后，客户端就可以向集群中的节点发送命令
    2.当客户端发送与数据库键有关的命令时，接受的节点会计算出当前的键属于那一个槽
        1）如果槽就是当前节点负责，则执行相应的命令
        2）如果槽不是当前节点，则返回MOVE错误，指引客户端转向正确的节点
        
    tips：
    1.计算槽的方法：
      CRC16(key)&16438
    2.判断是否是当前节点负责
      clusterState.slots数组的索引i是否是当前节点，如果不是，转向其对应的clusterNode，获取IP／Port 
      指引客户端跳到正确的节点
      
   **一个集群的客户端，将会与集群中的多个节点进行套接字的连接，而所谓的节点转向，实则是换一个套接字发送命令，如果尚未连接，则先会创建连接再执行命令**
   
#6 节点数据库的实现
    1.节点的数据库和单机时使用的数据库完全一致，但是节点只能使用0号数据库
    
#7 重新分片
    1.Redis可以将已经指派给某个节点的槽，改为指派给另一个节点。并且将相关槽所属键值对也从源节点移动到目标节点。
    2.重新分片可以在线（online）进行，集群不需要下线，并且源节点和目标节点可以继续处理命令请求。
    
    分片原理：
    redis集群的重新分片是由redis集群管理软件redis-trib负责执行的
    
    1）redis-trib对目标节点发送命令cluster setslot importing，让目标节点准备好从源节点导入属于槽slot的键值对
    2）redis-trib对源节点发送命令cluster setslot migrating，让源节点准备好将属于槽的键值对迁移至目标节点
    3）redis-trib获取 源节点 属于槽的若干个键值对
    4）将被选择的键值对 原子性的从源节点迁移到目标节点
    5）向集群中的其他节点，告知将槽 指派给了 其他节点
    
    可能产生的问题：
    1）在分片的过程中，客户端向源节点发送数据库键有关的命令，如果源节点找到指定的键则返回，如果未找到，则返回ASK错误，指引客户端转向正在导入槽的目标节点
    2）ASK前，客户端需要向目标节点发送ASKING命令，否则直接发送命令，会被目标节点拒绝
    3）目标节点收到命令，检查正在导入槽的数据，如果键所对应的槽正在被导入，将破格执行命令
    
    注意：
    1）ASK错误是一次性的（短暂的）
    2）MOVE错误则非一次性的。客户端遇到关于槽i的请求，则会直接向目前负责槽i的节点发送
    
#8 复制和故障转移
    1.集群中的主节点可以有自己的从节点，正常情况下，复制主节点。异常情况，则可以替补为主节点
    
    复制：
    1）命令：cluster replicate <node_id> ，让接受命令的节点成为node_id的从节点
    2）一个节点成为从节点后，并开始复制主节点这一个信息，会通过消息发送给其他的节点。集群中的其他节点都会在代表主节点的clusterNode结构的slaves属性和
      numslaves属性中记录正在复制这个主节点的从节点名单。
      
    故障转移判定：
    1）集群中的每一个节点都会定期向其他节点发送PING消息，以检测对方是否存活。如果在规定时间内未收到回复，可以判定为疑似下线。
    2）一旦判定为疑似下线，该节点将设置clusterState.node的目标节点的状态为PFAIL
    3）集群中的各个节点会相互发送消息来交换集群中各个节点的状态信息
   **在一个集群里面，超过半数负责处理槽的主节点，认为某个主节点X疑似下线，那么这个主节点将会标记为下线状态（FAIL）**
   **将主节点X标识为已下线的节点，会向集群的其他节点广播消息，其他节点立即将主节点标识为下线状态**
    
    故障转移步骤：
    1）从线下的主节点的从节点中选举产生一个新的主节点
    2）被选中的节点执行slaveof no one 成为新的主节点
    3）新的主节点接管原主节点所管理的槽
    4）新的主节点向集群发送PONG消息，告知其他节点当前节点已经成为了主节点，并接管了原节点的槽
    
   **选主的算法和sentinel选主的算法一直，都是基于raft的领头选举来实现的**
    
#9 消息
    1.种类：节点之间发送的消息主要包含以下5类：
        1）MEET
        2）PING
        3）PONG
        4）FAIL
        5）PUBLISH
    
    2.GOSSIP协议由MEET\PING\PONG消息实现的
      GOSSIP协议需要一段时候后才能传播至整个集群
    
    3.MEET、PING、PONG三个消息里面都将携带两个被选举出来的节点的信息
    
        节点A--PING（包含B\C节点信息）--节点D
        节点D--PONG（包含E\F节点信息）--节点A
    4.FAIL
        FAIL不采用GOSSIP协议，因为需要尽快让集群的其他节点知道。所以是广播
        
    5.PUBLISH
        1）客户端向A节点发送publish channel msg 指令
        2）A节点向channel频道发送消息msg
        3）A向集群广播一条PUBLISH消息，所有接收到的节点都会向channel频道发送msg
        
        
    