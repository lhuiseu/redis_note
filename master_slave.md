#1 指令
    
    1.slaveof host port
#2 概念
    1.同步
      从服务器的数据库状态 更新至 主服务器的数据库状态
    2.命令传播
      主服务器状态修改时，让主从回归一致的方式
#3 实现
###2.1
    复制时机：
    
    1. 初始复制，从服务器没有复制过任何主服务器／从服务器复制的主服务器和上一次不同
    
    2. 短线后重复制，命令传播阶段，主服务器因为网络原因而中断了复制，从服务器通过重新连接，继续复制
###2.2 旧版复制
    步骤：
    
    1.从服务器向主服务器发送SYNC命令
    2.主服务器启动子进程，执行BGSAVE命令，生成RDB文件
    3.使用一个缓冲区，记录从现在开始执行的写命令
    4.主服务器生成RDB文件后，发送给从服务器，从服务器载入RDB，恢复和主服务器数据库一致的状态
    5.主服务器将缓冲区的命令发送给从服务器，从服务器执行写所有的命令
    
    
    缺陷：
    1.SYNC非常的耗费资源。
        1）当生成RDB文件的时候，消耗服务器的CPU、内存以及磁盘IO资源
        2）主服务器将RDB发送给从服务器的时候，耗费网络资源
        3）从服务器载入RDB时，服务器阻塞，无法处理命令请求
        
###2.3 新版复制
    PSYNC命令代替SYNC命令
    
    模式：
    1.完整重同步（初次服务情况）
    2.部分重同步（断线后复制）
    
    部分重同步实现必备条件：
    1.存储"复制偏移量"
        1）主从服务器分别维护一个"复制偏移量"，主从同步命令的时候，每次主服务器都将自己的偏移量（字节为单位）
        传播给从服务器，从服务器再更改自己的偏移量。通过对比偏移量，可以很清楚的知道主从服务器是否一致
        2）每次从服务器断线后重连接，都向主服务器发送自己的偏移量，主服务器决策是否是完整重同步还是部分重同步
        
    2.主服务器设置 复制积压缓冲区
        1）主服务器怎么抉择是否采用哪种模式？复制缓冲积压区 是一个固定长度FIFO的队列，主服务器再发送命令的时候，不仅发送给从服务器，
        同时还会将命令写入复制积压缓冲区。
        2）如果从服务器发送过来的偏移量还在缓冲区当中，则执行部分重同步
        3）复制积压缓冲区的大小是可以调整的。默认是1M。
        估算时间：2*从服务器重新连接时间*每秒处理的命令数
    
    3.服务器运行的ID（runid）
        1）主从同步的时候，主服务器会将自己的runid带给从服务器
        2）从服务器重新连接一个服务器的时候，会将之前保存的主服务器runid发送过去
#4 流程
    1.客户端发送slaveof命令（异步命令），服务设置好服务器的状态（将主服务器的 host\ip写入redisServer）
    2.建立套接字连接。从服务器会为这个套接字关联一个文件事件处理器，这个处理器将负责后续的复制工作，和主服务器命令的执行
      主服务器将为该套接字创建相应的客户端状态（从服务器在主服务器眼中，就是客户端）
    3.从服务与主服务建立连接后，发送PING命令。存在三种情况：
        1）从服务器在规定的timeout时间内，未读出命令回复的内容，说明网络状态不佳，从服务器断开重新创建与主服务器的套接字
        2）主服务器返回ERR，说明暂时无法处理请求。从服务器断开重新创建与主服务器的套接字
        3）从服务器收到"PONG"命令，正常
    4. 身份验证
    5. 发送从服务器的端口信息，主服务器收到端口信息后，会在客户端对应的状态设置slave_listening_port属性
    6. 同步。从服务器向主服务器发送PSYNC命令。
    7. PSYNC命令以后，主服务器也称为从服务器的客户端，需要向从服务器发送命令。主服务器在执行命令传播的时候，也是从服务器的客户端
    8. 命令传播
    
#5 心跳检测
    1. 主从服务器可以发送REPLCONF ACK命令（默认1s一次心跳）来检测两者之间的状态是否OK
    注意：REPLCONF ACK会带上 从服务器的偏移量
    
    2. **重点**：当命令丢失的情况下，通过心跳，主服务器可以及时感知到命令的丢失，并且向从服务器
    "补发"命令。（和部分复制很像，但是这种情况下是未断线的情况）
   
    